# Lem-in: Ant Farm Pathfinding Simulator

A sophisticated pathfinding algorithm that simulates moving ants through an interconnected tunnel system from a start room to an end room in the minimum number of steps.

## üë• Contributors
This project was developed collaboratively by:
- **gtristan** (me)
- **gtapioca**

## üêú Project Overview

Lem-in is an algorithmic challenge that involves finding the most efficient way to move a specified number of ants through a network of rooms connected by tunnels. The goal is to get all ants from the start room to the end room in the **minimum number of turns**, where each turn allows each ant to move through one tunnel.

### Key Challenges:
- **Multiple pathfinding**: Finding not just one, but multiple non-intersecting paths
- **Path optimization**: Balancing path length vs. path quantity based on ant count
- **Flow optimization**: Determining optimal ant distribution across available paths
- **Collision avoidance**: Ensuring ants don't collide in tunnels or rooms (except start/end)

## üöÄ How to Build and Run

### Prerequisites
- GCC compiler
- Make
- Python 3.x (for visualizers)

### Building
```bash
# Compiling main program
make

# Preparing environment for visualization
python3 -m venv venv
source ./venv/bin/activate
pip install -r requirements.txt
```

### Basic Usage
```bash
./lem-in < map_file.map
```
for enriched output with number of moves and number of ants, that took each path:
```bash
./lem-in -n < map_file.map
```

### With Visualization
```bash
# Pygame visualizer (requires python3 and pygame)
./lem-in < map_file.map | python3 pygame_visualizer.py
```

## üó∫Ô∏è Map Generator

The project includes a third-party map generator tool that creates test maps with various complexity levels and characteristics.

### Generator Usage
```bash
./generator_linux [options]
```

### Available Options:
- `--help` : Display the manual and available options
- `--flow-one` : Generate an ant farm with distinctive paths and **1** ant
- `--flow-ten` : Generate an ant farm with distinctive paths and approximately **10** ants  
- `--flow-thousand` : Generate an ant farm with distinctive paths and approximately **1000** ants
- `--big` : Generate a large map with approximately **4000** rooms to test time complexity.
- `--big-superposition` : Generate a large map with **overlapping paths** for complex scenarios

### Example Usage:
```bash
# Generate and test a map with 10 ants
./generator_linux --flow-ten > test_map.map
./lem-in < test_map.map

# Performance testing with big map
./generator_linux --big > big_test.map
time ./lem-in < big_test.map
```

### ‚ö†Ô∏è Visualization Limitation:
**Note**: Maps generated by this tool place all rooms in a linear alignment (single line), which makes them unsuitable for convenient visualization. The generated maps are primarily designed for **algorithmic testing and performance benchmarking** rather than visual demonstration. For better visualization experience, use manually created maps like `maps/example.map` where rooms have proper spatial distribution.

## üìã Map Format

### Input Structure
```
number_of_ants
##start
start_room x_coordinate y_coordinate
##end
end_room x_coordinate y_coordinate
room_name x_coordinate y_coordinate
...
room1-room2
room2-room3
...
```

### Example Map
```
4
3 2 2
##start
start 4 0
##end
end 4 6
4 0 4
1 4 2
2 4 4
5 8 2
6 8 4
start-1
3-4
2-4
1-5
6-5
end-6
1-2
2-end
3-start
```

### Map Rules
- **First line**: Number of ants (positive integer)
- **Rooms**: Each room has a unique name and coordinates (name x y)
- **Special rooms**: Exactly one start room (`##start`) and one end room (`##end`)
- **Tunnels**: Connections between rooms (`room1-room2`)
- **Comments**: Lines starting with `#` (except `##start` and `##end`)
- **Constraints**: 
  - Room names cannot start with 'L' or contain '-'
  - No duplicate room names
  - Coordinates must be integers

## üéØ Algorithm Strategy

### The Path Intersection Problem

This is the most complex aspect of lem-in. Consider this scenario:

```
   [start]
    / |
 [3] [1]--[5]
 /    |    |
[4]--[2]  [6]
      |   /
     [end]
```

With this network:
- **Short path**: Start ‚Üí 1 ‚Üí 2 ‚Üí End (3 steps)
- **Alternative path 1**: Start ‚Üí 3 ‚Üí 4 ‚Üí 2 ‚Üí End (4 steps)
- **Alternative path 2**: Start ‚Üí 1 ‚Üí 5 ‚Üí 6 ‚Üí End (4 steps)

#### Decision Making Based on Ant Count:

**Few ants (1-3)**: Use the shortest path
- 1 ant: Start ‚Üí 1 ‚Üí 2 ‚Üí End (3 steps)
- 2-3 ants: They can use different paths simultaneously or take the shortest path one after another. In Any case they will need 4 steps for 2 ants and 5 steps for 3 ants.

**Many ants (4+)**: Multiple paths become beneficial
| Number of Ants | One path    | Two paths  |
| -------------- | ----------- |----------- |
| 4              | 6 steps     | 5 steps    |
| 10             | 12 steps    | 8 steps    |
| 100            | 102 steps   | 53 steps   |


### Path Selection Algorithm

1. **Find all possible paths** from start to end
2. **Identify path intersections** (rooms where paths overlap)
3. **Calculate optimal combinations** based on:
   - Path lengths
   - Number of available paths
   - Ant count
   - Intersection penalties

4. **Dynamic programming approach**:
   ```
   If (ants ‚â§ shortest_path_capacity):
       Use shortest paths only
   Else:
       Calculate: min(turns_with_shortest_only, turns_with_multiple_paths)
       Choose better option
   ```

## üìä Output Format

The program outputs:
1. **Complete input** (echoed back)
2. **Movement sequence**: Each line represents one turn
   ```
    L1-3 L2-1
    L1-4 L3-3 L2-5 L4-1
    L1-2 L3-4 L2-6 L4-5
    L1-end L3-2 L2-end L4-6
    L3-end L4-end
   ```

Where `LX-roomY` means ant X moves to roomY.

## üéÆ Visualizer
- **Features**: Smooth animations, synchronized movement, interactive controls
- **Controls**: 
  - Play/Pause: Spacebar
  - Step: S key
  - Reset: R key
  - Speed: Mouse wheel

## üîç Performance Considerations

According to the project requirements, *"the algorithm must render within a reasonable time, even in a case with 4000 rooms. 2 or 3 seconds is great, 9 seconds is mediocre, 15 seconds is too much."* For the current implementation:

```
$ time  ./generator_linux --big | ./lem-in
./generator_linux --big  0,55s user 0,00s system 99% cpu 0,557 total
./lem-in  0,19s user 0,12s system 36% cpu 0,874 total
```

This demonstrates that the program completes the largest benchmark map in under 1 second, which is well within the optimal performance range.

## Error Handling:
- Invalid map format
- Impossible paths (no route from start to end)
- Invalid room names or connections
- Memory allocation failures

---

*This implementation demonstrates advanced algorithmic thinking, combining graph theory, dynamic programming, and flow optimization to solve a complex pathfinding challenge.*
